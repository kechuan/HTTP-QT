#ifndef HTMLFLITER_H
#define HTMLFLITER_H

#include <regex>
#include <string>
#include <QDebug>

inline std::regex DiskReg(R"(\w:)");
inline std::regex HTMLLinkReg(R"(<\s*a\s+[^>]*href\s*=\s*"([^/view/]+[^"]*))", std::regex::icase);                      //target group1
inline std::regex HTMLDiskReg(R"((path=)+(.*))", std::regex::icase);                                                    //target group1
inline std::regex HTMLNameReg(R"(<\s*div\s+[^>]*class\s*=\"(dirname|filename)\">+([^<]*))", std::regex::icase);       //target group2
inline std::regex HTMLSizeReg(R"(<\s*div\s*+[^>]*class\s*=\"filesize\">+([^<]*))", std::regex::icase);                //target group1

inline std::regex MenuContentMatch(R"(<ul>+(.*?)+</ul>)");                                                      //target group0
inline std::regex listSegment(R"(<div\s*id=\"list\">)");

inline std::regex fileslistSegments(R"(<ul\s*id='fileslist'>.*?</ul>)"); //catchGroup 1
inline std::regex HTMLTypeFliter(R"(<use\sxlink:href="#ext-(\w+)[^>])"); //catchGroup 1

inline std::smatch matches;


inline void copy_template(std::string& string, std::regex &regexp, size_t &&matchGroup , std::vector<std::string> &stringVector){
    std::copy(
        std::sregex_token_iterator(string.begin(), string.end(), regexp, matchGroup), //有效迭代器 代表first
        std::sregex_token_iterator(), //空迭代器 代表范围的终止 last
        //相当于旧容器的起始与终止
        std::back_inserter(stringVector) //获取到的值操作
    );
}

//剪切导航栏上的超链接信息 以便获取上一级文件夹的跳转位置
inline std::string HTMLFliter(std::string &Information,std::vector<std::string> &PathVector){
    std::string tempString = std::move(Information);
    std::string MenuContent;

    while (std::regex_search(tempString, matches, MenuContentMatch)) { //修剪并获取信息
        tempString = matches.suffix(); //命中之后就把命中内容从string修剪掉
        MenuContent+=matches[0]; //matches[0] 代表find到的所有东西 同时在新字符串内增加内容 从而实现匹配内容的转移
    }

    copy_template(MenuContent,HTMLLinkReg,1,PathVector);

    //当代迷思 为什么要加这一段才可以 有效
    //for(auto &Path:PathVector) qDebug("Path:%s\n",Path.c_str());

    while (std::regex_search(tempString, matches, listSegment)) {    //仅修剪
        tempString = matches.suffix(); 
        /*   命中之后就把命中内容从string修剪掉 
         *   这里指代<div id="list">开始之外的所有内容 以给下文作其他的Fliter
         */
    }

    return tempString;
};

//获取磁盘根目录信息
inline void HTMLExtract(std::string &Information,std::vector<std::string> &LinkVector, std::vector<std::string> &NameVector){

    //reset all content
    LinkVector.clear(); LinkVector.shrink_to_fit();
    NameVector.clear(); NameVector.shrink_to_fit();

    copy_template(Information,HTMLLinkReg,1,LinkVector);

    for(auto &currentLink:LinkVector){
        std::copy( //STL -> copy
            std::sregex_token_iterator(currentLink.begin(), currentLink.end(), HTMLDiskReg, 2),
            std::sregex_token_iterator(),
            std::back_inserter(NameVector)
        );
    }

}

//获取dirlist内部信息&fileslist内部信息
inline void HTMLExtract(std::string &Information,std::vector<std::string> &LinkVector, std::vector<std::string> &PathVector, std::vector<std::string> &NameVector, std::vector<std::string> &SizeVector, std::vector<std::string> &TypeVector){

    //reset all content
    LinkVector.clear(); LinkVector.shrink_to_fit();
    PathVector.clear(); PathVector.shrink_to_fit();
    NameVector.clear(); NameVector.shrink_to_fit();
    SizeVector.clear(); SizeVector.shrink_to_fit();
    TypeVector.clear(); TypeVector.shrink_to_fit();

    //Fliter real Information.

    std::string FilteredInformation = std::move(HTMLFliter(Information,PathVector));
    copy_template(FilteredInformation,HTMLLinkReg,1,LinkVector);
    copy_template(FilteredInformation,HTMLSizeReg,1,SizeVector);
    copy_template(FilteredInformation,HTMLNameReg,2,NameVector);

    std::string filelistString;

    while (std::regex_search(FilteredInformation, matches, fileslistSegments)){
        FilteredInformation = matches.suffix();
        filelistString+=matches[0];
    }

    //填充dir到TypeVector内以保持其他Vector长度同步
    
    std::vector<std::string> tempVector;
    copy_template(filelistString,HTMLTypeFliter,1,tempVector);

    for(int fillIndex = 0;fillIndex<SizeVector.size() - tempVector.size();++fillIndex){
        TypeVector.emplace_back("dir");
    }

    //最后通过insert拼贴 不要忘了it本质是指针! 或者用copy也是一样的 (begin,end,back_inserter(TypeVector))
    TypeVector.insert(TypeVector.end(),tempVector.begin(),tempVector.end());


    //for(auto &Path:PathVector) qDebug("Path:%s",Path.c_str());
    //for(auto &Link:LinkVector) qDebug("Link:%s",Link.c_str());
    for(auto &Type:TypeVector) qDebug("Type:%s",Type.c_str());
    //不要直接使用 for(iter:<容器>) 因为会导致一次拷贝构造

}

#endif
